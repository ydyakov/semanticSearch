<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Slide 5 - Vector similarity Models </title>
    <link rel="stylesheet" href="style.css">
    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
            "csg": "https://cdn.jsdelivr.net/gh/looeee/threejs-csg@main/src/CSG/CSG.js"
          }
        }
    </script>
    <style type="text/css">
        #scene-container {
            width: 100%;
            height: 100%;
        }
        html, body {
            height: 100%;
            margin: 0;
        }

        .content {
            height: 100%;
            width: 100%;
        }

        .main-section {
            height: calc(100% - 40px); /* footer height */
            width: 100%;
        }

        .slide-content {
            height: 100%;
            width: 100%;
        }

    </style>
    <!--<script src="main.js" defer></script>-->
</head>
<body data-slide="5">

    <div class="content">
        <main class="main-section">
            <div class="slide-content">
                <div id="scene-container"></div>


            </div>
        </main>

        <footer class="footer">
            <div class="footer-left">
                <span>Yordan Dyakov</span>
            </div>
            <div class="footer-right">
                <a href="slide4.html" class="nav-btn">⬅</a>
                <a href="slide6.html" class="nav-btn">➡</a>
            </div>
        </footer>
    </div>

    <script type="module">
        import * as THREE from "three";

        const container = document.getElementById("scene-container");

        // =======================
        // Renderer
        // =======================
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // =======================
        // Scene & Camera
        // =======================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0e0e0e);

        const camera = new THREE.PerspectiveCamera(
            60,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 14);

        // =======================
        // Lights
        // =======================
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dir = new THREE.DirectionalLight(0xffffff, 0.6);
        dir.position.set(5, 5, 5);
        scene.add(dir);

        // =======================
        // Math helpers
        // =======================
        function normalize(v) {
            const len = Math.hypot(...v);
            return v.map(x => x / len);
        }

        function cosineSimilarity(a, b) {
            let dot = 0;
            for (let i = 0; i < a.length; i++) dot += a[i] * b[i];
            return dot;
        }

        // =======================
        // Text sprite
        // =======================
        function createTextSprite(text) {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            canvas.width = 256;
            canvas.height = 64;

            ctx.fillStyle = "white";
            ctx.font = "28px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);

            sprite.scale.set(2, 0.5, 1);
            return sprite;
        }

        // =======================
        // Arrow + label
        // =======================
        function addVectorArrow(vec, color, label) {
            const dir = new THREE.Vector3(vec[0], vec[1], vec[2]).normalize();
            const length = 5;

            const arrow = new THREE.ArrowHelper(
                dir,
                new THREE.Vector3(0, 0, 0),
                length,
                color,
                0.5,
                0.3
            );
            scene.add(arrow);

            const labelSprite = createTextSprite(label);
            labelSprite.position.copy(dir.clone().multiplyScalar(length + 0.7));
            scene.add(labelSprite);

            return dir.clone().multiplyScalar(length);
        }

        // =======================
        // Example embeddings
        // =======================
        const vectors = {
            // ---- COLORS CLUSTER (близо до color) ----
            red: normalize([0.9, 0.1, 0.2]),
            blue: normalize([0.4, 0.2, 0.5]),
            yellow: normalize([0.8, 0.6, 0.1]),

            // център на color cluster
            color: normalize([0.7, 0.4, 0.5]),

            // ---- SHAPES CLUSTER (близо помежду си, далеч от color) ----
            circle: normalize([-0.9, 0.3, 0.0]),
            square: normalize([-0.8, 0.5, -0.1]),
            rectangle: normalize([-0.85, 0.4, -0.2])
        };


        // =======================
        // Draw arrows
        // =======================
        const positions = {};
        positions.red = addVectorArrow(vectors.red, 0xff0000, "red");
        positions.blue = addVectorArrow(vectors.blue, 0x0000ff, "blue");
        positions.yellow = addVectorArrow(vectors.yellow, 0xffff00, "yellow");

        positions.circle = addVectorArrow(vectors.circle, 0x00ffcc, "circle");
        positions.square = addVectorArrow(vectors.square, 0xcc00ff, "square");
        positions.rectangle = addVectorArrow(vectors.rectangle, 0xcc00ff, "rectangle");  
        
        positions.color = addVectorArrow(vectors.color, 0xffffff, "color");

        // =======================
        // Nearest neighbors lines
        // =======================
        const neighbors = ["red", "blue", "yellow"];

        neighbors.forEach(name => {
            const sim = cosineSimilarity(vectors.color, vectors[name]);

            // Line
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                positions[name]
            ]);

            const material = new THREE.LineBasicMaterial({ color: 0xffffff });
            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // Similarity label
            const mid = positions[name].clone().multiplyScalar(0.5);
            const label = createTextSprite(`cos = ${sim.toFixed(2)}`);
            label.position.copy(mid);
            scene.add(label);
        });

        // =======================
        // Mouse rotation (X + Y)
        // =======================
        let isDragging = false;
        let prevX = 0;
        let prevY = 0;

        container.addEventListener("mousedown", e => {
            isDragging = true;
            prevX = e.clientX;
            prevY = e.clientY;
        });

        window.addEventListener("mouseup", () => isDragging = false);

        window.addEventListener("mousemove", e => {
            if (!isDragging) return;

            const dx = e.clientX - prevX;
            const dy = e.clientY - prevY;

            prevX = e.clientX;
            prevY = e.clientY;

            scene.rotation.y += dx * 0.005;
            scene.rotation.x += dy * 0.005;

            scene.rotation.x = THREE.MathUtils.clamp(
                scene.rotation.x,
                -Math.PI / 2,
                Math.PI / 2
            );
        });

        // =======================
        // Zoom
        // =======================
        container.addEventListener("wheel", e => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, 6, 30);
        });

        // =======================
        // Resize
        // =======================
        window.addEventListener("resize", () => {
            renderer.setSize(container.clientWidth, container.clientHeight);
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
        });

        // =======================
        // Animate
        // =======================
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
    </script>



</body>
</html>
